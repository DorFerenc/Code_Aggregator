Project Code Aggregation
Generated on: 2024-09-14 10:35:02.261887

================================================================================
File: docker-compose.yml
================================================================================

version: '3'

services:
  web:
    build:
      context: .
      dockerfile: /Dockerfile
    ports:
      - "5000:5000"
    depends_on:
      - mongo
    environment:
      - MONGODB_URI=mongodb://mongo:27017/dromo
      - FLASK_ENV=development
    volumes:
      - ./app:/app/app
      - ./run.py:/app/run.py
      - ./uploads:/app/uploads
    command: gunicorn --bind 0.0.0.0:5000 run:app

  mongo:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh --quiet
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 40s

  test:
    build:
      context: .
      dockerfile: /Dockerfile
    volumes:
      - .:/app
    depends_on:
      mongo:
        condition: service_healthy
    environment:
      - MONGODB_URI=mongodb://mongo:27017/dromo_test
      - FLASK_ENV=testing
    # command: pytest

volumes:
  mongodb_data:

================================================================================
File: Dockerfile
================================================================================

# Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory in the container
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Make port 5000 available to the world outside this container
EXPOSE 5000

# Define environment variable
ENV FLASK_APP=run.py

# Run the application with gunicorn
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "run:app"]

================================================================================
File: README.md
================================================================================

# DroMo Project

DroMo is an automated 3D model generation system designed to streamline and automate the process of creating 3D models from captured visuals.

## Getting Started

These instructions will help you set up and run the project on your local machine for development and testing purposes.

### Prerequisites

- Python 3.9+
- Docker
- MongoDb

### Installation

1. Clone the repository:
2. Add a `.env` file in root project with this info:
```
FLASK_APP=run.py
FLASK_ENV=development
MONGODB_URI=mongodb://localhost:27017/dromo
SECRET_KEY=your-secret-key-here
UPLOAD_FOLDER=/app/uploads
```
3. Open MongoDB and Docker
4. ```docker compose build```
5. ```docker compose up```
6. `localhost:5000`

### Test

1. run: ```docker compose run test pytest```

# DEV:

### API Endpoint Chart
| Resource | Address | Method | Parameters | Responses | Status Codes |
| -------- | ------- | ------ | ---------- | --------- | ------------ |
| Upload Visual Data | `/api/upload` | POST | - `title`: String<br>- `file`: Multipart Video | - `message`: Upload success<br>- `video_id`: MongoDB ID | 200, 400, 500 |
| List all videos | `/api/videos` | GET | None | Array of video objects | 200, 500 |
| Get video details | `/api/videos/<id>` | GET | - `id`: String (Video ID) | Video object | 200, 404, 500 |
| Delete a video | `/api/videos/<id>` | DELETE | - `id`: String (Video ID) | - `message`: Deletion success | 200, 404, 500 |
| Monitor Progress | `/api/progress/<id>` | GET | - `id`: String (Video ID) | - `video_id`: String<br>- `progress`: int (0-100)<br>- `status`: String | 200, 404, 500 |
| Preprocess Visual Data | `/api/preprocess/<id>` | POST | - `id`: String (Video ID) | - `message`: Preprocessing started<br>- `preprocessed_data_id`: String | 200, 404, 500 |
| Monitor Preprocessing Progress | `/api/preprocess/progress/<id>` | GET | - `id`: String (Preprocessed Data ID) | - `preprocessed_data_id`: String<br>- `progress`: int (0-100)<br>- `status`: String | 200, 404, 500 |
| Reconstruct 3D Model | `/api/reconstruct/<id>` | POST | - `id`: String (Preprocessed Data ID) | - `message`: Reconstruction started<br>- `model_id`: String | 200, 404, 500 |
| Monitor Reconstruction Progress | `/api/reconstruct/progress/<id>` | GET | - `id`: String (Model ID) | - `model_id`: String<br>- `progress`: int (0-100)<br>- `status`: String | 200, 404, 500 |
| Export 3D Model | `/api/export/<id>` | GET | - `id`: String (Model ID) | - `model_id`: String<br>- `file_path`: String<br>- `metadata`: Object | 200, 404, 500 |

### Structure
```
dromo/
│
├── app/
│   ├── __init__.py
│   ├── config.py
│   ├── models/
│   │   ├── __init__.py
│   │   └── video.py
│   ├── services/
│   │   ├── __init__.py
│   │   └── video_service.py
│   ├── api/
│   │   ├── __init__.py
│   │   └── routes.py
│   └── db/
│       ├── __init__.py
│       └── mongodb.py
├── tests/
│   ├── __init__.py
│   └── test_api.py
├── Dockerfile
├── docker-compose.yml
├── requirements.txt
└── run.py
```

================================================================================
File: requirements.txt
================================================================================

Flask==2.0.1
Werkzeug==2.0.1
Flask-PyMongo==2.3.0
pymongo==3.12.0
pytest==6.2.5
python-dotenv==0.19.0
gunicorn==20.1.0

================================================================================
File: run.py
================================================================================

"""
Entry point for the DROMO application.

This script creates and runs the Flask application.
"""

from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)

================================================================================
File: app\config.py
================================================================================

"""Application configuration."""

import os
from datetime import timedelta

class Config:
    """Base configuration class."""

    SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'
    MONGO_URI = os.environ.get('MONGODB_URI', 'mongodb://localhost:27017/dromo')
    UPLOAD_FOLDER = os.environ.get('UPLOAD_FOLDER', '/app/uploads')
    ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov'}
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB max upload size

================================================================================
File: app\__init__.py
================================================================================

"""Main application module."""

from flask import Flask
from app.config import Config
from app.db.mongodb import init_db
from app.api.routes import api_bp
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env file

def create_app(config_class=Config):
    """
    Create and configure the Flask application.

    Args:
        config_class: Configuration class (default: Config)

    Returns:
        Flask: Configured Flask application instance
    """
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Initialize extensions
    init_db(app)

    # Register blueprints
    app.register_blueprint(api_bp)

    return app

================================================================================
File: app\api\routes.py
================================================================================

"""API routes for the DROMO system."""

from flask import Blueprint, request, jsonify, current_app
from werkzeug.utils import secure_filename
from app.services.video_service import VideoService
from bson import ObjectId
import os

api_bp = Blueprint('api', __name__)
video_service = VideoService()

@api_bp.route('/', methods=['GET'])
def home():
    return jsonify({"message": "Welcome to the DROMO API"}), 200

@api_bp.route('/api/upload', methods=['POST'])
def upload_visual_data():
    """
    Handle the upload of visual data.

    Expects:
        - A 'file' in the request files
        - A 'title' in the form data (optional)

    Returns:
        JSON response with upload status and video ID.
    """
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    title = request.form.get('title', 'Untitled')

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)

        video_id = video_service.create_video(title, file_path)

        return jsonify({
            "message": "Upload success",
            "video_id": video_id
        }), 200
    else:
        return jsonify({"error": "File type not allowed"}), 400

def allowed_file(filename):
    """
    Check if the file extension is allowed.

    Args:
        filename (str): The name of the file to check.

    Returns:
        bool: True if the file extension is allowed, False otherwise.
    """
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']


@api_bp.route('/api/videos/<video_id>', methods=['GET'])
def get_video(video_id):
    """Retrieve information about a specific video."""
    video = video_service.get_video(video_id)
    if video:
        return jsonify({
            'id': str(video['_id']),
            'title': video['title'],
            'file_path': video['file_path'],
            'timestamp': video['timestamp'] #.isoformat()
        }), 200
    else:
        return jsonify({'error': 'Video not found or invalid ID'}), 404


@api_bp.route('/api/videos', methods=['GET'])
def list_videos():
    """List all videos."""
    videos = video_service.get_all_videos()
    return jsonify([{
        'id': str(video['_id']),
        'title': video['title'],
        'timestamp': video['timestamp'] # .isoformat()
    } for video in videos]), 200


@api_bp.route('/api/videos/<video_id>', methods=['DELETE'])
def delete_video(video_id):
    """Delete a specific video."""
    result = video_service.delete_video(video_id)
    if result:
        return jsonify({'message': 'Video deleted successfully'}), 200
    else:
        return jsonify({'error': 'Video not found or invalid ID'}), 404


================================================================================
File: app\api\__init__.py
================================================================================



================================================================================
File: app\db\mongodb.py
================================================================================

"""MongoDB database connection and initialization."""

from flask_pymongo import PyMongo
from pymongo.errors import ConnectionFailure
from flask import current_app
import logging

mongo = PyMongo()

def init_db(app):
    """
    Initialize the MongoDB connection.

    Args:
        app (Flask): The Flask application instance.

    Raises:
        ConnectionFailure: If unable to connect to the MongoDB instance.
    """
    mongo.init_app(app)

    try:
        # The ismaster command is cheap and does not require auth.
        mongo.cx.admin.command('ismaster')
        logging.info("MongoDB connection successful.")
    except ConnectionFailure:
        logging.error("MongoDB connection failed.")
        raise

def get_db():
    """
    Get the database connection.

    Returns:
        pymongo.database.Database: The MongoDB database instance.
    """
    return mongo.db

================================================================================
File: app\db\__init__.py
================================================================================



================================================================================
File: app\models\video.py
================================================================================

"""Video model for representing and interacting with video data."""

from datetime import datetime
from bson import ObjectId
from app.db.mongodb import get_db

class Video:
    """Represents a video in the system."""

    def __init__(self, title, file_path):
        """
        Initialize a new Video instance.

        Args:
            title (str): The title of the video.
            file_path (str): The path where the video file is stored.
        """
        self.title = title
        self.file_path = file_path
        self.timestamp = datetime.utcnow()

    def save(self):
        """
        Save the video to the database.

        Returns:
            str: The ID of the inserted video document.
        """
        db = get_db()
        result = db.videos.insert_one({
            'title': self.title,
            'file_path': self.file_path,
            'timestamp': self.timestamp
        })
        return str(result.inserted_id)

    @staticmethod
    def get_by_id(video_id):
        """
        Retrieve a video by its ID.

        Args:
            video_id (str): The ID of the video to retrieve.

        Returns:
            dict: The video document if found, None otherwise.
        """
        db = get_db()
        return db.videos.find_one({'_id': ObjectId(video_id)})

================================================================================
File: app\models\__init__.py
================================================================================

from pymongo import MongoClient
from flask import current_app

def get_db():
    client = MongoClient(current_app.config['MONGO_URI'])
    return client.get_default_database()

================================================================================
File: app\services\video_service.py
================================================================================

"""Service layer for video-related operations."""

from app.models.video import Video
from bson import ObjectId
from bson.errors import InvalidId
from app.db.mongodb import get_db

class VideoService:
    """Handles business logic for video operations."""

    @staticmethod
    def create_video(title, file_path):
        """
        Create a new video entry.

        Args:
            title (str): The title of the video.
            file_path (str): The path where the video file is stored.

        Returns:
            str: The ID of the created video.
        """
        video = Video(title=title, file_path=file_path)
        return video.save()

    @staticmethod
    def get_video(video_id):
        """
        Retrieve a video by its ID.

        Args:
            video_id (str): The ID of the video to retrieve.

        Returns:
            dict: The video data if found, None otherwise.
        """
        try:
            return Video.get_by_id(video_id)
        except InvalidId:
            return None
        # return Video.get_by_id(video_id)

    @staticmethod
    def get_all_videos():
        """Retrieve all videos."""
        db = get_db()
        return list(db.videos.find())

    @staticmethod
    def delete_video(video_id):
        """Delete a video by its ID."""
        try:
            db = get_db()
            result = db.videos.delete_one({'_id': ObjectId(video_id)})
            return result.deleted_count > 0
        except InvalidId:
            return False

================================================================================
File: app\services\__init__.py
================================================================================



================================================================================
File: tests\test_api.py
================================================================================

"""
Feature: DROMO API Functionality
    As a user of the DROMO system
    I want to be able to upload visual data and interact with the API
    So that I can use the 3D model generation capabilities
"""

import pytest
from app import create_app
from app.db.mongodb import get_db
from io import BytesIO
import json
from bson import ObjectId

@pytest.fixture
def app():
    """Create and configure a new app instance for each test."""
    app = create_app()
    app.config.update({
        'TESTING': True,
        'MONGODB_URI': 'mongodb://mongo:27017/dromo_test'
    })
    yield app

@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()

@pytest.fixture
def client2():
    app = create_app()
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

@pytest.fixture
def mongo(app):
    """Create a MongoDB test database and drop it after the test."""
    with app.app_context():
        db = get_db()
        yield db
        db.client.drop_database(db.name)

def test_home_route(client):
    """
    Scenario: Access the home route
        When I send a GET request to the home route
        Then I should receive a welcome message
    """
    response = client.get('/')
    assert response.status_code == 200
    assert b"Welcome to the DROMO API" in response.data

def test_upload_visual_data_success(client, mongo):
    """
    Scenario: Successfully upload visual data
        Given I have a video file
        When I upload the file with a title
        Then I should receive a success message
        And the file should be stored in the database
    """
    data = {
        'title': 'Test Video',
        'file': (BytesIO(b'fake video content'), 'test_video.mp4')
    }
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 200

    response_data = json.loads(response.data.decode('utf-8'))
    assert "message" in response_data
    assert "video_id" in response_data
    assert response_data["message"] == "Upload success"

    # Check if the video was stored in MongoDB
    video = mongo.videos.find_one({'_id': ObjectId(response_data['video_id'])})
    assert video is not None
    assert video['title'] == 'Test Video'
    assert 'file_path' in video

def test_upload_visual_data_no_file(client):
    """
    Scenario: Attempt to upload without a file
        Given I don't include a file in my upload
        When I try to upload
        Then I should receive an error message
    """
    data = {'title': 'Test Video'}
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 400
    assert b"No file part" in response.data

def test_upload_visual_data_no_filename(client):
    """
    Scenario: Attempt to upload a file with no filename
        Given I include a file with no filename
        When I try to upload
        Then I should receive an error message
    """
    data = {
        'title': 'Test Video',
        'file': (BytesIO(b'fake video content'), '')
    }
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 400
    assert b"No selected file" in response.data

def test_upload_visual_data_invalid_extension(client):
    """
    Scenario: Attempt to upload a file with invalid extension
        Given I have a file with an invalid extension
        When I try to upload the file
        Then I should receive an error message
    """
    data = {
        'title': 'Test Document',
        'file': (BytesIO(b'fake document content'), 'test_document.txt')
    }
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 400
    assert b"File type not allowed" in response.data

def test_mongodb_connection(app):
    """
    Scenario: Check MongoDB connection
        Given the application is configured with a MongoDB URI
        When I attempt to connect to the database
        Then the connection should be successful
    """
    with app.app_context():
        db = get_db()
        assert db.command('ping')['ok'] == 1

def test_video_retrieval(client, mongo):
    """
    Scenario: Retrieve uploaded video information
        Given I have uploaded a video
        When I request information about the video
        Then I should receive the correct video details
    """
    # First, upload a video
    upload_data = {
        'title': 'Retrieval Test Video',
        'file': (BytesIO(b'fake video content for retrieval'), 'retrieval_test.mp4')
    }
    upload_response = client.post('/api/upload', data=upload_data, content_type='multipart/form-data')
    upload_result = json.loads(upload_response.data.decode('utf-8'))
    video_id = upload_result['video_id']

    # Now, retrieve the video information
    response = client.get(f'/api/videos/{video_id}')
    assert response.status_code == 200

    video_data = json.loads(response.data.decode('utf-8'))
    assert video_data['title'] == 'Retrieval Test Video'
    assert 'file_path' in video_data
    assert 'timestamp' in video_data

def test_list_videos(client, mongo):
    """
    Scenario: List all videos
        Given there are videos in the database
        When I request the list of videos
        Then I should receive a list of all videos
    """
    # Add some test videos to the database
    mongo.videos.insert_many([
        {'title': 'Video 1', 'file_path': '/path/to/video1.mp4', 'timestamp': '2024-09-14T10:00:00'},
        {'title': 'Video 2', 'file_path': '/path/to/video2.mp4', 'timestamp': '2024-09-14T11:00:00'}
    ])

    response = client.get('/api/videos')
    assert response.status_code == 200

    videos = json.loads(response.data.decode('utf-8'))
    assert len(videos) == 2
    assert videos[0]['title'] == 'Video 1'
    assert videos[1]['title'] == 'Video 2'
    assert 'timestamp' in videos[0]
    assert 'timestamp' in videos[1]

def test_get_video_details(client, mongo):
    """
    Scenario: Get video details
        Given there is a video in the database
        When I request the details of that video
        Then I should receive the correct video information
    """
    video = mongo.videos.insert_one({
        'title': 'Test Video',
        'file_path': '/path/to/test_video.mp4',
        'timestamp': '2024-09-14T12:00:00'
    })

    response = client.get(f'/api/videos/{str(video.inserted_id)}')
    assert response.status_code == 200

    video_data = json.loads(response.data.decode('utf-8'))
    assert video_data['title'] == 'Test Video'
    assert video_data['file_path'] == '/path/to/test_video.mp4'
    assert video_data['timestamp'] == '2024-09-14T12:00:00'

def test_get_nonexistent_video(client):
    """
    Scenario: Get details of a non-existent video
        Given there is no video with a specific ID in the database
        When I request the details of that video
        Then I should receive a 404 error
    """
    nonexistent_id = str(ObjectId())
    response = client.get(f'/api/videos/{nonexistent_id}')
    assert response.status_code == 404

def test_delete_video(client, mongo):
    """
    Scenario: Delete a video
        Given there is a video in the database
        When I request to delete that video
        Then the video should be removed from the database
    """
    video = mongo.videos.insert_one({
        'title': 'Video to Delete',
        'file_path': '/path/to/delete_video.mp4',
        'timestamp': '2024-09-14T13:00:00'
    })

    response = client.delete(f'/api/videos/{str(video.inserted_id)}')
    assert response.status_code == 200

    # Check that the video was actually deleted
    assert mongo.videos.find_one({'_id': video.inserted_id}) is None


def test_delete_nonexistent_video(client):
    """
    Scenario: Delete a non-existent video
        Given there is no video with a specific ID in the database
        When I request to delete that video
        Then I should receive a 404 error
    """
    nonexistent_id = str(ObjectId())
    response = client.delete(f'/api/videos/{nonexistent_id}')
    assert response.status_code == 404

def test_invalid_video_id(client):
    """
    Scenario: Use an invalid video ID
        Given an invalid video ID is provided
        When I request to get or delete a video
        Then I should receive a 404 error
    """
    invalid_id = 'invalid_id'
    get_response = client.get(f'/api/videos/{invalid_id}')
    assert get_response.status_code == 404
    assert json.loads(get_response.data)['error'] == 'Video not found or invalid ID'

    delete_response = client.delete(f'/api/videos/{invalid_id}')
    assert delete_response.status_code == 404
    assert json.loads(delete_response.data)['error'] == 'Video not found or invalid ID'


================================================================================
File: tests\__init__.py
================================================================================



