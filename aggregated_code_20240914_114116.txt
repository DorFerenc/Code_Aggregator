Project Code Aggregation
Generated on: 2024-09-14 11:41:16.115506

Project Structure:
==================
Dromo_Structure/
├── .git
│   ├── COMMIT_EDITMSG
│   ├── HEAD
│   ├── config
│   ├── description
│   ├── hooks
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── fsmonitor-watchman.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── pre-merge-commit.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── pre-receive.sample
│   │   ├── prepare-commit-msg.sample
│   │   ├── push-to-checkout.sample
│   │   ├── sendemail-validate.sample
│   │   └── update.sample
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── HEAD
│   │   └── refs
│   │       ├── heads
│   │       │   └── master
│   │       └── remotes
│   │           └── origin
│   │               └── master
│   ├── objects
│   │   ├── 0a
│   │   │   └── b0fdf63afea80fb7867c16463b0f6bd9a573eb
│   │   ├── 11
│   │   │   └── d7bf8f0ed52b58290e23b769618f37433a7db7
│   │   ├── 18
│   │   │   └── 37e79b6d31c7ed57034012f2192a1b263ebd7f
│   │   ├── 35
│   │   │   └── 9f2747593b49eac7c6895decdfe656b6f90754
│   │   ├── 3f
│   │   │   └── 4191b5f3d3b76bdb84555eec1cd64f0bced05a
│   │   ├── 43
│   │   │   └── 1860aeda0c34a7825814dbca6c0d57e8882aab
│   │   ├── 48
│   │   │   └── c46e1256420703b4a572d86cad3ea8b08b4819
│   │   ├── 4a
│   │   │   └── 07a5416dc83ba996bdf1bb389baddd44b18827
│   │   ├── 4c
│   │   │   └── f0f9d34c1f5d145661ad99e23910cfea9c8d16
│   │   ├── 4f
│   │   │   └── b23758f9666a794df36736ce4aa65f1a5e0c97
│   │   ├── 55
│   │   │   └── 1ac4f00f0529e5a27952bf8cbcc44250908666
│   │   ├── 56
│   │   │   └── bef2af9943e55cdda1f8769842112fce1cbfcb
│   │   ├── 58
│   │   │   └── b134f133dd324279e72cc57ccdc5faaab2a5a8
│   │   ├── 5a
│   │   │   └── 51284a22ff49d23fbe4ced041d0b62b1d632e8
│   │   ├── 67
│   │   │   └── cc2528cdf1d9a7fbd1c0ba977747dac506c240
│   │   ├── 76
│   │   │   └── 967625866d6760275d53c711f675ef93c8175e
│   │   ├── 7b
│   │   │   └── 848645ccf4c3f7e23b0fe00d4c78f3e9d23a20
│   │   ├── 81
│   │   │   └── fab1f5ae599f00252f506dc92f1061c6f92a74
│   │   ├── 9c
│   │   │   └── ab55f4026cf81e50ebfa140e2f60ffe2f165cd
│   │   ├── a6
│   │   │   └── 60602066399f81c24e4803f5e6713fa9b43f81
│   │   ├── ac
│   │   │   ├── 1297e7e10b03c55a60f996b0a0d8b6d4529c46
│   │   │   └── 3456e56838c1e1595ac966164784acc33236ff
│   │   ├── ae
│   │   │   └── 99c7a1f06be8da63bf9f32aa4d3e32370ac424
│   │   ├── b3
│   │   │   └── d67a5604f799c1e42b1fa855b903a3038c194c
│   │   ├── b4
│   │   │   └── 8e305c22a0bca7c82d31d3f47377b25b58ea8a
│   │   ├── b5
│   │   │   └── e39db564f6625eda672c0fc9371f581f8564c5
│   │   ├── c1
│   │   │   └── 8ad5cec0d58d2a328df5abbc2b6887cd6f11cc
│   │   ├── c8
│   │   │   ├── 56709fc1c19d5d7abd04f9cbafe83ce317fc16
│   │   │   └── 95899c4dd21a849df57427a9071d0f1c51da99
│   │   ├── ce
│   │   │   └── 504e9b2481421a5d76069ab9fcd199aaeeda76
│   │   ├── da
│   │   │   └── 2f4c8a333df2b9e235445fdb9ae5ea4ccf6e7c
│   │   ├── db
│   │   │   └── 545159e2ea23e6cb231033cf8701b37df858cb
│   │   ├── dc
│   │   │   └── 496d9ce25d5418412221ff4bfbed4e082fc6b8
│   │   ├── de
│   │   │   └── f2064312a0c8029bd191a15d18fd3daa7456fe
│   │   ├── e6
│   │   │   └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
│   │   ├── e8
│   │   │   ├── 8c8aca5702b6e1b993c319161e9d69cda6abe8
│   │   │   └── 9b31815e0da0f1d18b3ec1e568196002df0d62
│   │   ├── ed
│   │   │   └── 45790de94a9b6531a0fbcc3ea99261d9ebb24c
│   │   ├── ee
│   │   │   └── 9d1aae398b3fb60f5b28847b3fc65f7b0a82d3
│   │   ├── f9
│   │   │   └── 4dde3d98769b8bf64d9619d62297d314ac77f4
│   │   ├── fa
│   │   │   └── 1b65a1af2667deb21e6b7abd988988157ed9d9
│   │   ├── fe
│   │   │   └── d0223318e39534884f98e873fb1b00794ca44b
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       │   └── master
│       ├── remotes
│       │   └── origin
│       │       └── master
│       └── tags
├── .gitignore
├── Dockerfile
├── README.md
├── app
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── config.py
│   ├── db
│   │   ├── __init__.py
│   │   └── mongodb.py
│   ├── models
│   │   ├── __init__.py
│   │   └── video.py
│   ├── services
│   │   ├── __init__.py
│   │   └── video_service.py
│   └── static
│       └── index.html
├── docker-compose.yml
├── requirements.txt
├── run.py
├── tests
│   ├── __init__.py
│   └── test_api.py
└── uploads
    ├── retrieval_test.mp4
    └── test_video.mp4

File Contents:
==============

================================================================================
File: docker-compose.yml
================================================================================

version: '3'

services:
  web:
    build:
      context: .
      dockerfile: /Dockerfile
    ports:
      - "5000:5000"
    depends_on:
      - mongo
    environment:
      - MONGODB_URI=mongodb://mongo:27017/dromo
      - FLASK_ENV=development
    volumes:
      - ./app:/app/app
      - ./run.py:/app/run.py
      - ./uploads:/app/uploads
    command: gunicorn --bind 0.0.0.0:5000 run:app

  mongo:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh --quiet
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 40s

  test:
    build:
      context: .
      dockerfile: /Dockerfile
    volumes:
      - .:/app
    depends_on:
      mongo:
        condition: service_healthy
    environment:
      - MONGODB_URI=mongodb://mongo:27017/dromo_test
      - FLASK_ENV=testing
    # command: pytest

volumes:
  mongodb_data:

================================================================================
File: Dockerfile
================================================================================

# Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory in the container
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Make port 5000 available to the world outside this container
EXPOSE 5000

# Define environment variable
ENV FLASK_APP=run.py

# Run the application with gunicorn
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "run:app"]

================================================================================
File: README.md
================================================================================

# DroMo Project

DroMo is an automated 3D model generation system designed to streamline and automate the process of creating 3D models from captured visuals.

## Getting Started

These instructions will help you set up and run the project on your local machine for development and testing purposes.

### Prerequisites

- Python 3.9+
- Docker
- MongoDb

### Installation

1. Clone the repository:
2. Add a `.env` file in root project with this info:
```
FLASK_APP=run.py
FLASK_ENV=development
MONGODB_URI=mongodb://localhost:27017/dromo
SECRET_KEY=your-secret-key-here
UPLOAD_FOLDER=/app/uploads
```
3. Open MongoDB and Docker
4. ```docker compose build```
5. ```docker compose up```
6. `localhost:5000`

### Test

1. run: ```docker compose run test pytest```

# DEV:

### API Endpoint Chart
| Resource | Address | Method | Parameters | Responses | Status Codes |
| -------- | ------- | ------ | ---------- | --------- | ------------ |
| Upload Visual Data | `/api/upload` | POST | - `title`: String<br>- `file`: Multipart Video | - `message`: Upload success<br>- `video_id`: MongoDB ID | 200, 400, 500 |
| List all videos | `/api/videos` | GET | None | Array of video objects | 200, 500 |
| Get video details | `/api/videos/<id>` | GET | - `id`: String (Video ID) | Video object | 200, 404, 500 |
| Delete a video | `/api/videos/<id>` | DELETE | - `id`: String (Video ID) | - `message`: Deletion success | 200, 404, 500 |
| Monitor Progress | `/api/progress/<id>` | GET | - `id`: String (Video ID) | - `video_id`: String<br>- `progress`: int (0-100)<br>- `status`: String | 200, 404, 500 |
| Preprocess Visual Data | `/api/preprocess/<id>` | POST | - `id`: String (Video ID) | - `message`: Preprocessing started<br>- `preprocessed_data_id`: String | 200, 404, 500 |
| Monitor Preprocessing Progress | `/api/preprocess/progress/<id>` | GET | - `id`: String (Preprocessed Data ID) | - `preprocessed_data_id`: String<br>- `progress`: int (0-100)<br>- `status`: String | 200, 404, 500 |
| Reconstruct 3D Model | `/api/reconstruct/<id>` | POST | - `id`: String (Preprocessed Data ID) | - `message`: Reconstruction started<br>- `model_id`: String | 200, 404, 500 |
| Monitor Reconstruction Progress | `/api/reconstruct/progress/<id>` | GET | - `id`: String (Model ID) | - `model_id`: String<br>- `progress`: int (0-100)<br>- `status`: String | 200, 404, 500 |
| Export 3D Model | `/api/export/<id>` | GET | - `id`: String (Model ID) | - `model_id`: String<br>- `file_path`: String<br>- `metadata`: Object | 200, 404, 500 |

### Structure
```
dromo/
│
├── app/
│   ├── __init__.py
│   ├── config.py
│   ├── models/
│   │   ├── __init__.py
│   │   └── video.py
│   ├── services/
│   │   ├── __init__.py
│   │   └── video_service.py
│   ├── api/
│   │   ├── __init__.py
│   │   └── routes.py
│   └── db/
│       ├── __init__.py
│       └── mongodb.py
├── tests/
│   ├── __init__.py
│   └── test_api.py
├── Dockerfile
├── docker-compose.yml
├── requirements.txt
└── run.py
```

================================================================================
File: requirements.txt
================================================================================

Flask==2.0.1
Werkzeug==2.0.1
Flask-PyMongo==2.3.0
pymongo==3.12.0
pytest==6.2.5
python-dotenv==0.19.0
gunicorn==20.1.0
Flask-CORS==3.0.10

================================================================================
File: run.py
================================================================================

"""
Entry point for the DROMO application.

This script creates and runs the Flask application.
"""

from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)

================================================================================
File: app\config.py
================================================================================

"""Application configuration."""

import os
from datetime import timedelta

class Config:
    """Base configuration class."""

    SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'
    MONGO_URI = os.environ.get('MONGODB_URI', 'mongodb://localhost:27017/dromo')
    UPLOAD_FOLDER = os.environ.get('UPLOAD_FOLDER', '/app/uploads')
    ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov'}
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB max upload size

================================================================================
File: app\__init__.py
================================================================================

"""Main application module."""

from flask import Flask, send_from_directory
from flask_cors import CORS
from app.config import Config
from app.db.mongodb import init_db
from app.api.routes import api_bp
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env file

def create_app(config_class=Config):
    """
    Create and configure the Flask application.

    Args:
        config_class: Configuration class (default: Config)

    Returns:
        Flask: Configured Flask application instance
    """
    app = Flask(__name__, static_folder='static')
    app.config.from_object(config_class)

    # Enable CORS
    CORS(app)

    # Initialize extensions
    init_db(app)

    # Register blueprints
    app.register_blueprint(api_bp, url_prefix='/api')

    @app.route('/')
    def serve_frontend():
        """Serve the frontend HTML file."""
        return send_from_directory(app.static_folder, 'index.html')

    return app

    # app = Flask(__name__)
    # app.config.from_object(config_class)

    # # Initialize extensions
    # init_db(app)

    # # Register blueprints
    # app.register_blueprint(api_bp)

    # return app

================================================================================
File: app\api\routes.py
================================================================================

"""API routes for the DROMO system."""

from flask import Blueprint, request, jsonify, current_app
from werkzeug.utils import secure_filename
from app.services.video_service import VideoService
from bson import ObjectId
import os

api_bp = Blueprint('api', __name__)
video_service = VideoService()

# @api_bp.route('/', methods=['GET'])
# def home():
#     return jsonify({"message": "Welcome to the DROMO API"}), 200

@api_bp.route('/api/upload', methods=['POST'])
def upload_visual_data():
    """
    Handle the upload of visual data.

    Expects:
        - A 'file' in the request files
        - A 'title' in the form data (optional)

    Returns:
        JSON response with upload status and video ID.
    """
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    title = request.form.get('title', 'Untitled')

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)

        video_id = video_service.create_video(title, file_path)

        return jsonify({
            "message": "Upload success",
            "video_id": video_id
        }), 200
    else:
        return jsonify({"error": "File type not allowed"}), 400

def allowed_file(filename):
    """
    Check if the file extension is allowed.

    Args:
        filename (str): The name of the file to check.

    Returns:
        bool: True if the file extension is allowed, False otherwise.
    """
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']


@api_bp.route('/api/videos/<video_id>', methods=['GET'])
def get_video(video_id):
    """Retrieve information about a specific video."""
    video = video_service.get_video(video_id)
    if video:
        return jsonify({
            'id': str(video['_id']),
            'title': video['title'],
            'file_path': video['file_path'],
            'timestamp': video['timestamp'] #.isoformat()
        }), 200
    else:
        return jsonify({'error': 'Video not found or invalid ID'}), 404


@api_bp.route('/api/videos', methods=['GET'])
def list_videos():
    """List all videos."""
    videos = video_service.get_all_videos()
    return jsonify([{
        'id': str(video['_id']),
        'title': video['title'],
        'timestamp': video['timestamp'] # .isoformat()
    } for video in videos]), 200


@api_bp.route('/api/videos/<video_id>', methods=['DELETE'])
def delete_video(video_id):
    """Delete a specific video."""
    result = video_service.delete_video(video_id)
    if result:
        return jsonify({'message': 'Video deleted successfully'}), 200
    else:
        return jsonify({'error': 'Video not found or invalid ID'}), 404


================================================================================
File: app\api\__init__.py
================================================================================



================================================================================
File: app\db\mongodb.py
================================================================================

"""MongoDB database connection and initialization."""

from flask_pymongo import PyMongo
from pymongo.errors import ConnectionFailure
from flask import current_app
import logging

mongo = PyMongo()

def init_db(app):
    """
    Initialize the MongoDB connection.

    Args:
        app (Flask): The Flask application instance.

    Raises:
        ConnectionFailure: If unable to connect to the MongoDB instance.
    """
    mongo.init_app(app)

    try:
        # The ismaster command is cheap and does not require auth.
        mongo.cx.admin.command('ismaster')
        logging.info("MongoDB connection successful.")
    except ConnectionFailure:
        logging.error("MongoDB connection failed.")
        raise

def get_db():
    """
    Get the database connection.

    Returns:
        pymongo.database.Database: The MongoDB database instance.
    """
    return mongo.db

================================================================================
File: app\db\__init__.py
================================================================================



================================================================================
File: app\models\video.py
================================================================================

"""Video model for representing and interacting with video data."""

from datetime import datetime
from bson import ObjectId
from app.db.mongodb import get_db

class Video:
    """Represents a video in the system."""

    def __init__(self, title, file_path):
        """
        Initialize a new Video instance.

        Args:
            title (str): The title of the video.
            file_path (str): The path where the video file is stored.
        """
        self.title = title
        self.file_path = file_path
        self.timestamp = datetime.utcnow()

    def save(self):
        """
        Save the video to the database.

        Returns:
            str: The ID of the inserted video document.
        """
        db = get_db()
        result = db.videos.insert_one({
            'title': self.title,
            'file_path': self.file_path,
            'timestamp': self.timestamp
        })
        return str(result.inserted_id)

    @staticmethod
    def get_by_id(video_id):
        """
        Retrieve a video by its ID.

        Args:
            video_id (str): The ID of the video to retrieve.

        Returns:
            dict: The video document if found, None otherwise.
        """
        db = get_db()
        return db.videos.find_one({'_id': ObjectId(video_id)})

================================================================================
File: app\models\__init__.py
================================================================================

from pymongo import MongoClient
from flask import current_app

def get_db():
    client = MongoClient(current_app.config['MONGO_URI'])
    return client.get_default_database()

================================================================================
File: app\services\video_service.py
================================================================================

"""Service layer for video-related operations."""

from app.models.video import Video
from bson import ObjectId
from bson.errors import InvalidId
from app.db.mongodb import get_db

class VideoService:
    """Handles business logic for video operations."""

    @staticmethod
    def create_video(title, file_path):
        """
        Create a new video entry.

        Args:
            title (str): The title of the video.
            file_path (str): The path where the video file is stored.

        Returns:
            str: The ID of the created video.
        """
        video = Video(title=title, file_path=file_path)
        return video.save()

    @staticmethod
    def get_video(video_id):
        """
        Retrieve a video by its ID.

        Args:
            video_id (str): The ID of the video to retrieve.

        Returns:
            dict: The video data if found, None otherwise.
        """
        try:
            return Video.get_by_id(video_id)
        except InvalidId:
            return None
        # return Video.get_by_id(video_id)

    @staticmethod
    def get_all_videos():
        """Retrieve all videos."""
        db = get_db()
        return list(db.videos.find())

    @staticmethod
    def delete_video(video_id):
        """Delete a video by its ID."""
        try:
            db = get_db()
            result = db.videos.delete_one({'_id': ObjectId(video_id)})
            return result.deleted_count > 0
        except InvalidId:
            return False

================================================================================
File: app\services\__init__.py
================================================================================



================================================================================
File: app\static\index.html
================================================================================

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dromo - 3D Model Generation</title>
    <!-- Include Axios library for making HTTP requests -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
    <style>
        /* Base styles for the body */
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Styling for the main heading */
        h1 {
            color: #2c3e50;
        }

        /* Styling for each section of the page */
        .section {
            margin-bottom: 30px;
        }

        /* Styles for input fields */
        input[type="text"], input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
        }

        /* Base styles for buttons */
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            margin-right: 5px;
        }

        /* Hover effect for buttons */
        button:hover {
            background-color: #2980b9;
        }

        /* Specific styles for delete buttons */
        button.delete {
            background-color: #e74c3c;
        }

        button.delete:hover {
            background-color: #c0392b;
        }

        /* Styles for the video list */
        #videoList {
            list-style-type: none;
            padding: 0;
        }

        /* Styles for each item in the video list */
        #videoList li {
            background-color: #f9f9f9;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Styles for the video details section */
        #videoDetails {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Dromo - 3D Model Generation</h1>

    <!-- Section for uploading a new video -->
    <div class="section">
        <h2>Upload Video</h2>
        <input type="text" id="videoTitle" placeholder="Video Title">
        <input type="file" id="videoFile" accept="video/*">
        <button onclick="uploadVideo()">Upload</button>
    </div>

    <!-- Section for displaying the list of videos -->
    <div class="section">
        <h2>Video List</h2>
        <button onclick="listVideos()">Refresh Video List</button>
        <ul id="videoList"></ul>
    </div>

    <!-- Section for displaying details of a selected video -->
    <div class="section">
        <h2>Video Details</h2>
        <div id="videoDetails"></div>
    </div>

    <script>
        // Base URL for API requests
        const API_URL = 'http://localhost:5000/api';

        /**
         * Uploads a video to the server
         * Collects the title and file from input fields,
         * creates a FormData object, and sends a POST request to the server
         */
        async function uploadVideo() {
            const title = document.getElementById('videoTitle').value;
            const file = document.getElementById('videoFile').files[0];

            // Validate input
            if (!title || !file) {
                alert('Please provide both title and file');
                return;
            }

            const formData = new FormData();
            formData.append('title', title);
            formData.append('file', file);

            try {
                const response = await axios.post(`${API_URL}/upload`, formData, {
                    headers: { 'Content-Type': 'multipart/form-data' }
                });
                alert('Video uploaded successfully!');
                listVideos(); // Refresh the video list after successful upload
            } catch (error) {
                console.error('Error uploading video:', error);
                alert('Error uploading video');
            }
        }

        /**
         * Fetches the list of videos from the server and updates the UI
         * Sends a GET request to retrieve all videos and dynamically creates list items for each video
         */
        async function listVideos() {
            try {
                const response = await axios.get(`${API_URL}/videos`);
                const videoList = document.getElementById('videoList');
                videoList.innerHTML = ''; // Clear existing list
                response.data.forEach(video => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>${video.title}</span>
                        <div>
                            <button onclick="getVideoDetails('${video.id}')">Details</button>
                            <button class="delete" onclick="deleteVideo('${video.id}')">Delete</button>
                        </div>
                    `;
                    videoList.appendChild(li);
                });
            } catch (error) {
                console.error('Error listing videos:', error);
                alert('Error listing videos');
            }
        }

        /**
         * Fetches and displays details for a specific video
         * @param {string} id - The ID of the video to fetch details for
         * Sends a GET request for a specific video and updates the UI with the details
         */
        async function getVideoDetails(id) {
            try {
                const response = await axios.get(`${API_URL}/videos/${id}`);
                const videoDetails = document.getElementById('videoDetails');
                videoDetails.innerHTML = `
                    <h3>${response.data.title}</h3>
                    <p>ID: ${response.data.id}</p>
                    <p>File Path: ${response.data.file_path}</p>
                    <p>Timestamp: ${response.data.timestamp}</p>
                `;
            } catch (error) {
                console.error('Error getting video details:', error);
                alert('Error getting video details');
            }
        }

        /**
         * Deletes a video from the server
         * @param {string} id - The ID of the video to delete
         * Sends a DELETE request to remove a specific video, then refreshes the video list
         */
        async function deleteVideo(id) {
            if (confirm('Are you sure you want to delete this video?')) {
                try {
                    await axios.delete(`${API_URL}/videos/${id}`);
                    alert('Video deleted successfully');
                    listVideos(); // Refresh the list after deletion
                } catch (error) {
                    console.error('Error deleting video:', error);
                    alert('Error deleting video');
                }
            }
        }

        // Load the list of videos when the page is first opened
        listVideos();
    </script>
</body>
</html>

================================================================================
File: tests\test_api.py
================================================================================

"""
Feature: DROMO API Functionality
    As a user of the DROMO system
    I want to be able to upload visual data and interact with the API
    So that I can use the 3D model generation capabilities
"""

import pytest
from app import create_app
from app.db.mongodb import get_db
from io import BytesIO
import json
from bson import ObjectId

@pytest.fixture
def app():
    """Create and configure a new app instance for each test."""
    app = create_app()
    app.config.update({
        'TESTING': True,
        'MONGODB_URI': 'mongodb://mongo:27017/dromo_test'
    })
    yield app

@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()

@pytest.fixture
def client2():
    app = create_app()
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

@pytest.fixture
def mongo(app):
    """Create a MongoDB test database and drop it after the test."""
    with app.app_context():
        db = get_db()
        yield db
        db.client.drop_database(db.name)

def test_home_route(client):
    """
    Scenario: Access the home route
        When I send a GET request to the home route
        Then I should receive a welcome message
    """
    response = client.get('/')
    assert response.status_code == 200
    assert b"Welcome to the DROMO API" in response.data

def test_upload_visual_data_success(client, mongo):
    """
    Scenario: Successfully upload visual data
        Given I have a video file
        When I upload the file with a title
        Then I should receive a success message
        And the file should be stored in the database
    """
    data = {
        'title': 'Test Video',
        'file': (BytesIO(b'fake video content'), 'test_video.mp4')
    }
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 200

    response_data = json.loads(response.data.decode('utf-8'))
    assert "message" in response_data
    assert "video_id" in response_data
    assert response_data["message"] == "Upload success"

    # Check if the video was stored in MongoDB
    video = mongo.videos.find_one({'_id': ObjectId(response_data['video_id'])})
    assert video is not None
    assert video['title'] == 'Test Video'
    assert 'file_path' in video

def test_upload_visual_data_no_file(client):
    """
    Scenario: Attempt to upload without a file
        Given I don't include a file in my upload
        When I try to upload
        Then I should receive an error message
    """
    data = {'title': 'Test Video'}
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 400
    assert b"No file part" in response.data

def test_upload_visual_data_no_filename(client):
    """
    Scenario: Attempt to upload a file with no filename
        Given I include a file with no filename
        When I try to upload
        Then I should receive an error message
    """
    data = {
        'title': 'Test Video',
        'file': (BytesIO(b'fake video content'), '')
    }
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 400
    assert b"No selected file" in response.data

def test_upload_visual_data_invalid_extension(client):
    """
    Scenario: Attempt to upload a file with invalid extension
        Given I have a file with an invalid extension
        When I try to upload the file
        Then I should receive an error message
    """
    data = {
        'title': 'Test Document',
        'file': (BytesIO(b'fake document content'), 'test_document.txt')
    }
    response = client.post('/api/upload', data=data, content_type='multipart/form-data')
    assert response.status_code == 400
    assert b"File type not allowed" in response.data

def test_mongodb_connection(app):
    """
    Scenario: Check MongoDB connection
        Given the application is configured with a MongoDB URI
        When I attempt to connect to the database
        Then the connection should be successful
    """
    with app.app_context():
        db = get_db()
        assert db.command('ping')['ok'] == 1

def test_video_retrieval(client, mongo):
    """
    Scenario: Retrieve uploaded video information
        Given I have uploaded a video
        When I request information about the video
        Then I should receive the correct video details
    """
    # First, upload a video
    upload_data = {
        'title': 'Retrieval Test Video',
        'file': (BytesIO(b'fake video content for retrieval'), 'retrieval_test.mp4')
    }
    upload_response = client.post('/api/upload', data=upload_data, content_type='multipart/form-data')
    upload_result = json.loads(upload_response.data.decode('utf-8'))
    video_id = upload_result['video_id']

    # Now, retrieve the video information
    response = client.get(f'/api/videos/{video_id}')
    assert response.status_code == 200

    video_data = json.loads(response.data.decode('utf-8'))
    assert video_data['title'] == 'Retrieval Test Video'
    assert 'file_path' in video_data
    assert 'timestamp' in video_data

def test_list_videos(client, mongo):
    """
    Scenario: List all videos
        Given there are videos in the database
        When I request the list of videos
        Then I should receive a list of all videos
    """
    # Add some test videos to the database
    mongo.videos.insert_many([
        {'title': 'Video 1', 'file_path': '/path/to/video1.mp4', 'timestamp': '2024-09-14T10:00:00'},
        {'title': 'Video 2', 'file_path': '/path/to/video2.mp4', 'timestamp': '2024-09-14T11:00:00'}
    ])

    response = client.get('/api/videos')
    assert response.status_code == 200

    videos = json.loads(response.data.decode('utf-8'))
    assert len(videos) == 2
    assert videos[0]['title'] == 'Video 1'
    assert videos[1]['title'] == 'Video 2'
    assert 'timestamp' in videos[0]
    assert 'timestamp' in videos[1]

def test_get_video_details(client, mongo):
    """
    Scenario: Get video details
        Given there is a video in the database
        When I request the details of that video
        Then I should receive the correct video information
    """
    video = mongo.videos.insert_one({
        'title': 'Test Video',
        'file_path': '/path/to/test_video.mp4',
        'timestamp': '2024-09-14T12:00:00'
    })

    response = client.get(f'/api/videos/{str(video.inserted_id)}')
    assert response.status_code == 200

    video_data = json.loads(response.data.decode('utf-8'))
    assert video_data['title'] == 'Test Video'
    assert video_data['file_path'] == '/path/to/test_video.mp4'
    assert video_data['timestamp'] == '2024-09-14T12:00:00'

def test_get_nonexistent_video(client):
    """
    Scenario: Get details of a non-existent video
        Given there is no video with a specific ID in the database
        When I request the details of that video
        Then I should receive a 404 error
    """
    nonexistent_id = str(ObjectId())
    response = client.get(f'/api/videos/{nonexistent_id}')
    assert response.status_code == 404

def test_delete_video(client, mongo):
    """
    Scenario: Delete a video
        Given there is a video in the database
        When I request to delete that video
        Then the video should be removed from the database
    """
    video = mongo.videos.insert_one({
        'title': 'Video to Delete',
        'file_path': '/path/to/delete_video.mp4',
        'timestamp': '2024-09-14T13:00:00'
    })

    response = client.delete(f'/api/videos/{str(video.inserted_id)}')
    assert response.status_code == 200

    # Check that the video was actually deleted
    assert mongo.videos.find_one({'_id': video.inserted_id}) is None


def test_delete_nonexistent_video(client):
    """
    Scenario: Delete a non-existent video
        Given there is no video with a specific ID in the database
        When I request to delete that video
        Then I should receive a 404 error
    """
    nonexistent_id = str(ObjectId())
    response = client.delete(f'/api/videos/{nonexistent_id}')
    assert response.status_code == 404

def test_invalid_video_id(client):
    """
    Scenario: Use an invalid video ID
        Given an invalid video ID is provided
        When I request to get or delete a video
        Then I should receive a 404 error
    """
    invalid_id = 'invalid_id'
    get_response = client.get(f'/api/videos/{invalid_id}')
    assert get_response.status_code == 404
    assert json.loads(get_response.data)['error'] == 'Video not found or invalid ID'

    delete_response = client.delete(f'/api/videos/{invalid_id}')
    assert delete_response.status_code == 404
    assert json.loads(delete_response.data)['error'] == 'Video not found or invalid ID'


================================================================================
File: tests\__init__.py
================================================================================



